<================================================================>
<======================>   CHECKPOINT 4   <======================>
<================================================================>
Assignment:
    MP3
Checkpoint:
    CP4
Authors:
    sagnik3, dhruvs7, arasha3, rct4


<================================================================>
                              BUG 2
<================================================================>
problem: Syserror tests did not pass. Close was not returning failure on
already closed files.

fix: The first issue was that we were not checking for valid fd values
in our syscalls. Additionally, we were not checking that the file was closed
by making sure that flag was 1 before we closed the file.

resolved by: ryan, dhruv, sagnik, arash

commmit (if any):

Time: 2 hrs

<================================================================>
                              BUG 1
<================================================================>
problem: When running cat and grep, the write system calls were printing 
garbage instead of the correct information. 

fix: We realized with cat that our file_read had to be incorrect since 
ls worked and we knew ls used directory_read. Therefore, we examined our
file read and realized that the inode start pointer was determined by the 
fd, not the inode for the fd of the current process. We made this change 
for both file_read and directory_read and it seemed to work.

resolved by: ryan, dhruv, sagnik, arash

commmit (if any):

Time: 3 hrs


<================================================================>
<======================>   CHECKPOINT 3   <======================>
<================================================================>
Assignment:
    MP3
Checkpoint:
    CP3
Authors:
    sagnik3, dhruvs7, arasha3, rct4

<================================================================>
                              BUG 8
<================================================================>
problem: The calculation of esp was invalid, and was not retrieving the value 
of esp off the kernel stack. 

fix: We were not distinguishing the difference between the stack pointer in the 
kernel space and the stack pointer in the user space. We were saving the pcb->process_esp 
to USER_ESP instead of the value of esp retrieved from the kernel stack through assembly
linkage. We added assembly linkage to retrieve the value of esp in the kernel stack.

resolved by: ryan, dhruv, sagnik, arash

commmit (if any):

Time: 5 hrs

<================================================================>
                              BUG 7
<================================================================>
problem: When halt was finished, we were returning control to the user,
as we were able to type into the buffer after halt was finished.

fix: We initially thought that it was an issue with the jmp RETURN_EXECUTE
in halt, but after checking the slides, we realized that the esp and ebp that we
were retrieving from the pcb was that of the parent_pcb, not the current pcb.
This is problematic because the esp points to the return address of the program
that called the current process's program. Therefore, the esp and ebp
were being set to shell's(pid = 0) esp instead of ls's(pid = 1) esp, hence returning
control to the user space instead of the kernel space where shell was executing.

resolved by: ryan, dhruv, sagnik, arash

commmit (if any):

Time: 5 hrs

<================================================================>
                              BUG 6
<================================================================>
problem: We weren't entering the user program(shell) when we iret from system_execute
fix: The order in which we pushed the arguments to the kernel stack was invalid so iret
was popping those values into the wrong segment registers to the eip was incorrect.

fix: We checked the slides to see the order in which the arguments were pushed to the kernel stack.

resolved by: ryan, dhruv, sagnik, arash

commmit (if any):

Time: 5 hrs

<================================================================>
                              BUG 5
<================================================================>
problem: When we tried to load the user program into memory, we were loading the incorrect instructions.

fix: Instead of copying the program image into a buffer and copying the buffer into the physical memory,
we directly copied the program image from the dentry into physical memory directly using read_data

resolved by: ryan, dhruv, sagnik, arash

commmit (if any):

Time: 1 hr

<================================================================>
                              BUG 4
<================================================================>
problem: The page for user programs was not being mapped to physical memory correctly as determined by info tlb,
which mapped the page to physical address 0.

fix: We followed similar pointer arithmetic for the kernel paging as we did with the user program paging since we 
knew that the kernel paging worked. Since the shell is located at 8MB in physical memory as opposed to the kernel 
which is a 4 MB page starting at 4 MB. So instead, we took the same physical address that we used for kernel page
and multiplied it by 2.

resolved by: ryan, dhruv, sagnik, arash

commmit (if any):

Time: 10 hrs

<================================================================>
                              BUG 3
<================================================================>
problem: Program image was not being read from and loaded properly

fix: We had some minor issues with some pointer arithmetic for eip/esp that took us a long time to find, but
     we fixed them via some magic numbers.

resolved by: ryan, dhruv, sagnik, arash

commmit (if any):

Time: 10 hrs

<================================================================>
                              BUG 2
<================================================================>
problem: iret context not properly set up

fix: we were pushing arguments in the wrong order

resolved by: ryan, dhruv

commmit (if any):

Time: 2 hrs

<================================================================>
                              BUG 1
<================================================================>
problem: read_data reading invalid argument

fix:We didn't properly cast the address to the right type. Intially we read to a buffer and stored the buffer at the 0x08048000 address
    but then we read data directly to there

resolved by: ryan, sagnik

commmit (if any):

Time: ~1 hr


<================================================================>
<======================>   CHECKPOINT 2   <======================>
<================================================================>
Assignment: 
    MP3
Checkpoint:
    CP2
Authors:
    sagnik3, dhruvs7, arasha3, rct4

<================================================================>
                              BUG 12
<================================================================>
problem: We weren't able to find the file that 
         had a very large text with a very long name


resolved by: sagnik3 & arasha3

fix: We were automatically failing because when the filename was set to 32 
or more OR less than/equal to 0, we just broke out and said bad input
To fix this, we split the if statement between 0 and 32; if filename
is of length greater than 32, we clip filename_len to 32
and if it's <= 0, we return -1

Time: ~10 min

<================================================================>
                              BUG 11
<================================================================>
problem: Nothing was being printed out when we were reading bytes 
         in read data

resolved by: arasha3

fix: We were casting to the pointer type to find which block to reference in the
absolute block number table. We used gdb to do hex subtraction to find why we were at the wrong 
address. We removed the cast and used it as an intermediate value int32_t no pointer. 

Time: 5 Hr

<================================================================>
                              BUG 10
<================================================================>
problem: Page faults encountered for file sizes that are too large
 
fix: We included a control statement that checks if the current file has more bytes to be read
if(file_pos_in_dir + nbytes > inode->len){
    bytes_to_read = inode->len - file_pos_in_dir; //Adjust bytes that will be read if file size exceeded
}

resolved by: sagnik3 & arasha3

Time: 1 Hr


<================================================================>
                              BUG 9
<================================================================>
problem: read_dentry_by_name was not reading filename correctly

fix: filename < 32 letters was being filled up to 32 by null bytes; we needed to just end reading 


resolved by: sagnik3

Time: 30 mins

<================================================================>
                              BUG 8
<================================================================>
problem: read_dir was always reading the same file

fix: We kept on clipping the pointer to the current file in the directory
     being read; we instead made it a global ptr and incremented by 1 each time read_dir was called

resolved by: sagnik3

Time: 45 mins


<================================================================>
                              BUG 7
<================================================================>
problem: Filesystem was not properly mounted and we got page faults while initializing

fix:We just needed to properly set the boot filesys base address via multiboot module;
  we then had the mod_start passed into our filesys_init, got the boot block info, and set the dirs

resolved by: sagnik3

Time: ~10 mins


<================================================================>
                              BUG 6
<================================================================>
problem: Cursor does not move correctly with backspace input.

fix: On delete, attrib was set to 0, which turned off the output in that cell. 
Thus, when the cursor arrived at that cell, it would not output. We fixed this by 
making delete not affect atrrib to ensure that the cursor would show.

resolved by: rct4, dhruvs7

Time: 30 mins

<================================================================>
                              BUG 5
<================================================================>
problem: When typing a command to the terminal and hitting enter(which flushes the buffer),
we typed into the next command and then started deleting. Instead of stopping at the beginning 
of the line(first character in the row), we kept deleting the previous command, which should
not have happened since it was already entered in the previous prompt.
fix: We realized that at some point we were incrementing the keyb_char_count, effectively
allowing a backspace to happen even when it should not be possible since backspacing only requires
that keyb_char_count is greater than zero. We noticed that in keyb_main, we were incrementing
keyb_char_count in the penultimate if-statement that also displays printable characters to the screen.
To fix this, we decided to putc('\b') upon receiving the backspace scan code and sended the
end-of-interrupt.

resolved by: rct4, dhruvs7

Time: 1 hour

<================================================================>
                              BUG 4
<================================================================>
problem: We tested a case in which we entered the value "ssss" to the prompt
and then pressed enter. This displayed "ssss", but when we typed the next command
"aaaa" and hit enter, the previous command "ssss" was displaying, when it should
have been "aaaa"

fix: Through gdb we found that the keyboard buffer was not only storing 
the current command "aaaa", but also storing the previous command "ssss", 
making the combined command "ssss\naaaa\n". This is problematic because
the keyboard buffer should be flushed upon enter. To fix this,
we set the current location of keyb_buffer to '\0'.

resolved by: dhruvs7, rct4

Time: 1 hour

<================================================================>
                              BUG 3
<================================================================>
problem: When we were debugging, we accidentally did not close the test 
machine and rebuild the bootimg. This corrupted the mp3.img, which effectively
prevented future builds from incorporating the necessary changes to fix other bugs.

fix: We initially did not even realize that the build was being corrupted.
We realized this was happening when we wrote a message to the terminal
which we was sure was implemented correctly, and this change was not reflected.
So we read the documentation and realized that we needed to git checkout mp3.img, 
which replaces the current version of mp3.img. This change worked.

resolved by: dhruvs7, rct4

Time: 30 mins


<================================================================>
                              BUG 2
<================================================================>
problem: When we typed a command to the terminal, the command 
was being reprinted to the terminal but the newline was not being appended
to the print back so the cursor location was directly after the print back
instead of on the next line 

fix: When we tried GDB, we noticed that the keyboard buffer was being populated
properly with the newline being appended to the end of the message, so we 
knew that the logic in keyboard.c was working as intended. Similarly, GDB
showed us that the terminal buffer in terminal_write was properly populated
with the message given by the user and the newline appended at the end. So we knew 
the issue had to be read_bytes, since this was the only information besides the 
terminal buffer that was shared between terminal_write and the test. After looking at
terminal_read, we realized that terminal_read was not incrementing read_bytes, so
all information in the terminal buffer was being read except for the penultimate 
character, which was the newline. Therefore, we incremented read_bytes, which made
the next command prompt start at the next line. 

resolved by: dhruvs7, rct4

Time: 1.5 hours

<================================================================>
                              BUG 1
<================================================================>
problem: When we ran test_nodebug for the first time, we were bootloading.

fix: We suspected that there was an issue with writing to video memory 
since we thought that this put the kernel in a vulnerable state, causing GRUB
to panic and bootload repeatedly. We commented out the changes we made to putc
entirely and ran the putc that was provided to us, and this stopped the bootloading.
We ended up rewriting putc for the rest of the checkpoint, but this allowed us to fix
the other bugs 

resolved by: arasha3, sagnik3

Time: 1 hour

<================================================================>
<======================>   CHECKPOINT 1   <======================>
<================================================================>
Assignment:
    MP3
Checkpoint:
    CP1
Authors:
    sagnik3, dhruvs7, arasha3, rct4

<================================================================>
                              BUG 7
<================================================================>
problem: Page fault was not being reached for edge cases in page testing

fix: There was a stack imbalance in our asm routine for enabling
     the paging because of a stack imbalance at the beginning

resolved by: sagnik3

Time: 2 hours

<================================================================>
                              BUG 6
<================================================================>
problem: General protection fault thrown after typing first char
into keyboard.

fix: Before we were simply cli() before doing the keyboard logic.
We cleared and saved the flags which allowed the RTC to keep interrupting
the keyboard, preventing the exception from being thrown.

resolved by: rct4

Time: 2 hours

<================================================================>
                              BUG 5
<================================================================>
problem: General protection fault thrown before keyboard press.

fix: Initially the bounds for which we mapped the input to the set_2_table
were incorrect -- we were initially checking that the user input was greater 
than or equal to 0. This allowed the putc(0) to occur, which throws 
an exception. We changed the bounds to >= 2 and this prevented this 
exception from occuring

resolved by: rct4

Time: 2 hours


<================================================================>
                              BUG 4
<================================================================>
problem: The real-time-clock test was only displaying the image once
rather than updating every time the rtc_handler was invoked

fix: Initially we were not looping when calling test_interrupts() which means 
that the video memory was only being updated once, not every time the 
real-time-clock interrupt handler was firing off. Putting this video memory
update call in a while loop allowed the changes in the real-time-clock to
be reflected. We also fixed the PIC logic to initialize the master
PIC first and the slave PIC second rather than interweaving that logic.

resolved by: sagnik3 & dhruvs7

Time: 3 hours


<================================================================>
                              BUG 3
<================================================================>
problem: Text-mode images were not showing up on the screen when the 
RTC handler was invoked.

fix: We realized that the RTC interrupt handler was being invoked independently
but we were never reflecting the changes made by the RTC in the video memory.
After adding a test_interrupts() call these changes were reflected ultimately.

resolved by: dhruvs7 & sagnik3

Time: 1 hour



<================================================================>
                              BUG 2
<================================================================>
problem: The struct fields for the page directory and page table entries 
were not being recognized by the compiler.

fix: We linked the types.h to the paging script which ensured that the types
were recognized by the compiler
resolved by: sagnik3

Time: 1 hour



<================================================================>
                              BUG 1
<================================================================>
problem: The assembly script for enabling paging 
         was not being recognized by the compiler

fix: We realized that because the scripts had the same name (page.c and page.S),
     the compiler was writing them to the same object, so we renamed page.S to
     paging.S

resolved by: dhruvs7

Time: 1.5 hours

<================================================================>
<======================>        END       <======================>
<================================================================>